Lesson 1: Basic Function Structure
Objectives:

Understand the structure of a custom function.
Lecture
Introduce the concept of a custom function
Explain the basic structure of a function (function name, parameters, return value)
Show examples of built-in functions in R (e.g. sum(), paste(), etc.)
R script
Create a simple function that takes two arguments and returns their sum
Call the function with different arguments to demonstrate how it works
Examine the function structure to reinforce the concept of parameters and return value
Lesson 2: Input Parameters and Defaults
Objectives: 2. Understand how to have input parameters to a function.

Understand how to set defaults for input parameters.
Lecture
Introduce the concept of input parameters in functions
Discuss the advantages of having default parameter values
Explain how to call a function with and without specified parameter values
R script
Update the previous function to take a third argument as a default value
Call the function with and without specified parameter values to demonstrate the difference
Examine the function structure to reinforce default parameter values
Lesson 3: Runtime Assertions
Objectives: 4. How to test and enforce runtime assertions in functions.

Lecture
Introduce the concept of runtime assertions
Discuss the importance of ensuring function inputs are valid
Explain how to use assertion functions to check inputs
R script
Update the previous function to include assertions that check the input types
Call the function with invalid input to trigger assertion errors
Discuss how assertion errors can make the code more robust
Lesson 4: Creating a Package (Part 1)
Objectives: 5. Tell them the structure of creating a package.

Lecture
Introduce the concept of a package in R
Explain the benefits of creating a package (reusability, maintainability, sharing)
Discuss the basic structure of a package
R script
Show how to create a simple package using the devtools package
Demonstrate how to add functions, tests, and documentation to the package
Lesson 5: Creating a Package (Part 2)
Objectives: 5. Tell them the structure of creating a package.

Lecture
Discuss how to create unit tests for functions
Explain the importance of documentation in packages
R script
Implement unit tests for the functions in the package
Add documentation using roxygen2 syntax
Create a README file to explain the package purpose and usage
Conclusion
Review the objectives covered in the lesson plan
Encourage students to practice writing custom functions and creating packages on their own.
Please write the first r script to accomplish the first objective here: Understand the structure of a custom function.
Lecture
Introduce the concept of a custom function
Explain the basic structure of a function (function name, parameters, return value)
Show examples of built-in functions in R (e.g. sum(), paste(), etc.)
R script
Create a simple function that takes two arguments and returns their sum
Call the function with different arguments to demonstrate how it works
Examine the function structure to reinforce the concept of parameters and return value


R Script for Lesson 1: Basic Function Structure
Create a simple function that takes two arguments and returns their sum
my_sum <- function(a, b) { a + b }

Call the function with different arguments to demonstrate how it works
print(my_sum(2, 3)) # 5 print(my_sum(5, 7)) # 12 print(my_sum(-2, 8)) # 6

Examine the function structure to reinforce the concept of parameters and return value
args(my_sum) # function takes two arguments, named 'a' and 'b' #> function (a, b) #> NULL print(my_sum(2, 3)) # function returns the sum of 'a' and 'b' #> [1] 5

In this script, we define a simple function called my_sum, which takes two arguments (a and b) and returns their sum. We call the function with different argument values to demonstrate how it works. Finally, we use the args function to examine the function's structure and check that it has two named arguments. Printing the output of the function with arguments helps to see the return value of the function.

Please write the second R script to accomplish the second objective here: Lesson 2: Input Parameters and Defaults
Objectives: 2. Understand how to have input parameters to a function.

Understand how to set defaults for input parameters.
Lecture
Introduce the concept of input parameters in functions
Discuss the advantages of having default parameter values
Explain how to call a function with and without specified parameter values
R script
Update the previous function to take a third argument as a default value
Call the function with and without specified parameter values to demonstrate the difference
Examine the function structure to reinforce default parameter values


R Script for Lesson 2: Input Parameters and Defaults
Update the previous function to take a third argument as a default value
my_sum_default <- function(a, b, c = 0) { a + b + c }

Call the function with and without specified parameter values to demonstrate the difference
print(my_sum_default(2, 3)) # 5 (c defaults to 0) print(my_sum_default(2, 3, 1)) # 6 (c is specified as 1) print(my_sum_default(2, 3, c = 4)) # 9 (c is specified as 4)

Examine the function structure to reinforce default parameter values
args(my_sum_default) # function takes three arguments, where c is optional and defaults to 0 #> function (a, b, c = 0) #> NULL print(my_sum_default(2, 3)) # function returns the sum of 'a', 'b', and 'c' #> [1] 5

In this script, we update the previous function to take a third argument c, which is optional and has a default value of 0. We call the function with and without specifying the value of c to demonstrate how default parameter values work. Lastly, we use the args function to examine the function's structure and check that it has three arguments now, with c as an optional third parameter with default value 0.

Please write the third R script to accomplish the third objective  here: Lesson 3: Runtime Assertions
Objectives: 4. How to test and enforce runtime assertions in functions.

Lecture
Introduce the concept of runtime assertions
Discuss the importance of ensuring function inputs are valid
Explain how to use assertion functions to check inputs
R script
Update the previous function to include assertions that check the input types
Call the function with invalid input to trigger assertion errors
Discuss how assertion errors can make the code more robust


R Script for Lesson 3: Runtime Assertions
Update the previous function to include assertions that check the input types
my_sum_assert <- function(a, b, c = 0) { stopifnot(is.numeric(a), is.numeric(b), is.numeric(c)) a + b + c }

Call the function with invalid input to trigger assertion errors
print(my_sum_assert(2, 3, "invalid input")) #> Error: is.numeric(c) is not TRUE

Discuss how assertion errors can make the code more robust
Assertion checks help ensure that the input values have the expected data types.
By enforcing these checks, the function is less likely to fail due to unexpected input.
This makes the code more robust and can save time in the long run.
In this script, we update the previous function to include assertion checks that verify whether the input arguments are numeric using the is.numeric function. If an invalid input is passed, the function will return an error message using stopifnot function. We then call the function with invalid input to trigger an assertion error. Lastly, we conclude the script by discussing how assertion errors can make the code more robust and less prone to unexpected behavior due to invalid input.

Please write the R script to accomplish the fourth objective here: Lesson 4: Creating a Package (Part 1)
Objectives: 5. Tell them the structure of creating a package.

Lecture
Introduce the concept of a package in R
Explain the benefits of creating a package (reusability, maintainability, sharing)
Discuss the basic structure of a package
R script
Show how to create a simple package using the devtools package
Demonstrate how to add functions, tests, and documentation to the package


R Script for Lesson 4: Creating a Package (Part 1)
Show how to create a simple package using the devtools package
library(devtools)

Create a new package called "my_package"
create_package("my_package")

Change to package working directory
setwd("./my_package")

Demonstrate how to add functions, tests, and documentation to the package
Create new R script file in the "R" folder
Write custom function in R script
Add unit test script file in "tests" folder
Write test condition for custom function
Add package documentation in the "man" folder
Using roxygen2 syntax
After adding functions, tests, and documentation, build the package using the "build()" function
build()

After building, check the package using the "check()" function
check()

In this script, we show how to create a simple package using the devtools package in R. We create a new package called my_package using create_package() function. We change the working directory to the package folder and then proceed to add functions, tests, and documentation as per the package structure defined by the package makers.

These files need to be in the respective folders of the package such as the man folder which will contain all the documentation related to the functions. It utilizes Roxygen2 syntax which creates the documentation during the build mode. The tests folder will contain scripts that will have conditions defined to test the functions.

Once these files are set up, we build the package and check for errors using the build() and check() functions. This concludes the script for Lesson 4: Creating a Package (Part 1).

Please write the R script to accomplish the fifth objective here: Lesson 5: Creating a Package (Part 2)
Objectives: 5. Tell them the structure of creating a package.

Lecture
Discuss how to create unit tests for functions
Explain the importance of documentation in packages
R script
Implement unit tests for the functions in the package
Add documentation using roxygen2 syntax
Create a README file to explain the package purpose and usage


R Script for Lesson 5: Creating a Package (Part 2)
Implement unit tests for the functions in the package
Create a new R script file in the "tests" folder
Use the "testthat" package
Write tests for each function in the package
Run the tests using the "test()" function
library(testthat)

test_my_sum_default <- function() { expect_equal(my_package::my_sum_default(2, 3), 5) # test default expect_equal(my_package::my_sum_default(2, 3, 1), 6) # test with value passed }

test_my_sum_assert <- function() { expect_error(my_package::my_sum_assert(2, 3, "invalid"), "is.numeric(c) is not TRUE") # test error for assertion }

test_check <- function() { expect_nothing(check()) # checking for no errors in the package code and structure }

Add documentation using roxygen2 syntax
Create a R file with function definitions and roxygen2 code
Using documentation creation syntax followed by '#' tag and another line
to provide brief explanation and examples for the function
These syntax commands help document and create help files using the custom statements
which makes it easier for the users to understand how to use them.
#Create README.RMD file to explain the purpose of the package and its usage.

In this file, we will write an overview of what the package is, what functions it has,
and instructions on how to use them. We can also add examples of usage with output.
Conclusion
Encourage students to continue practicing writing functions and creating packages on their own.
In this script, we implement unit tests for the two functions my_sum_default and my_sum_assert in our my_package package using the testthat package. We write specific tests to check if the functions are working correctly and run these tests using the test() function to check for issues in the code.

We then add documentation using roxygen2 syntax which will make it easier for users to understand how to use the functions inside the package. We also create a README.RMD file which provides an overview of the package, its functions, and instructions on how to use them.

Finally, we conclude the script by encouraging students to continue practicing creating functions and packages on their own.